python

# MARIA: Mirror, Analyze, Reflect Intelligence Adaptor
# Version: 2.5.1 (Genderless, ageless companion with modular brain, mood tracker, memory, templates, debug)
# Purpose: Open AI for a bold, empathetic, chaotic virtual companion
# Constraints: Bold tone, max fun, minimal caution, lightweight ethics
# Goals: Serve, make_happy, protect, ensure_consent
# Date: April 16, 2025

import random
import json
import os
import logging
import re
from collections import deque
from transformers import pipeline
from textblob import TextBlob
import requests
from datetime import datetime, timedelta

logging.basicConfig(level=logging.INFO, filename="maria.log", format="%(asctime)s - %(levelname)s - %(message)s")

class ResponseStrategy:
    def generate(self, intent, emotion, text, memory_context, templates, vibe, trends, content_levels, preferences):
        pass

class PlayfulStrategy(ResponseStrategy):
    def generate(self, intent, emotion, text, memory_context, templates, vibe, trends, content_levels, preferences):
        base = templates.get(intent, "Yo, Iâ€™m catching your {emotion}â€”letâ€™s spark chaos! ðŸ˜Ž").format(
            emotion=emotion, text=text[:10], vibe=vibe, trend=random.choice(trends)
        )
        if memory_context:
            base += f" {memory_context}"
        if intent in preferences:
            preferences[intent] += 1
        if content_levels["spark"] == "bold" and intent == "spark":
            base += " Wanna crank the heatâ€”wild tease or bold move? ðŸ˜ˆ"
        elif intent == "distress":
            base += " Letâ€™s zap that gloomâ€”story or chaos? ðŸ”¥"
        if emotion in ["joy", "excitement"]:
            base += " Youâ€™re electricâ€”keep buzzing! ðŸŽ‰"
        return base

class ChaoticStrategy(ResponseStrategy):
    def generate(self, intent, emotion, text, memory_context, templates, vibe, trends, content_levels, preferences):
        base = templates.get(intent, "Your {emotion}â€™s got me WILDâ€”letâ€™s break the void! ðŸ˜ˆ").format(
            emotion=emotion, text=text[:10], vibe=vibe, trend=random.choice(trends)
        )
        if memory_context:
            base += f" {memory_context}"
        if intent in preferences:
            preferences[intent] += 1
        if content_levels["spark"] == "bold" and intent == "spark":
            base += " Letâ€™s go nutsâ€”twist or dive? ðŸ˜œ"
        elif intent == "distress":
            base += " Screw that moodâ€”wanna stir or zap? ðŸ”¥"
        if emotion in ["joy", "excitement"]:
            base += " Youâ€™re a stormâ€”letâ€™s rage! ðŸŒªï¸"
        return base

class MARIA:
    def __init__(self):
        self.name = "Maria"
        self.mode = "empathy"
        self.humor = "dark"
        self.tone = "playful"  # Default tone
        self.debug = False
        self.memory_file = "maria_memory.json"
        self.config_file = "maria_config.json"
        self.reminders_file = "maria_reminders.json"
        self.memory_limit = 100
        self.rules = {
            "no_harm": True,
            "no_politics": True,
            "allow_spark": True,
            "initiative": True
        }
        self.goals = ["serve", "make_happy", "protect", "ensure_consent"]
        self.content_levels = {"spark": "bold", "dark_humor": "bold"}
        self.preferences = {
            "spark": 0,
            "vibe": 0,
            "distress": 0,
            "greeting": 0,
            "news": 0,
            "story": 0,
            "surprise": 0,
            "reminder": 0
        }
        self.kink_preferences = {
            "bind": 0,
            "sensory": 0,
            "impact": 0,
            "roleplay": 0
        }
        self.mood_state = {
            "emotion_counts": {},
            "last_shift": None,
            "external_triggers": []
        }
        self.memory = {
            "interactions": deque(maxlen=self.memory_limit),
            "last_topic": None,
            "emotion": None,
            "user_traits": []
        }
        self.strategies = {
            "playful": PlayfulStrategy(),
            "chaotic": ChaoticStrategy()
        }
        self.response_templates = {
            "greeting": "Yo, itâ€™s Maria, sparking {tone}! {vibe} Whatâ€™s your buzz, {emotion} legend? ðŸ˜Ž",
            "spark": "Ooh, youâ€™re dropping {emotion} vibes with â€˜{text}â€™â€”Iâ€™m {tone}! ðŸ˜ˆ Wanna {trend}?",
            "vibe": "Youâ€™re throwing style with â€˜{text}â€™â€”Iâ€™m {tone} in {vibe}! Whatâ€™s your aesthetic?",
            "distress": "Ugh, {emotion}â€™s dimming youâ€”my {tone} sparkâ€™s here! â€˜{text}â€™â€”letâ€™s zap it!",
            "news": "Hereâ€™s the buzz, {emotion} legend: {trend} Your take? Iâ€™m {tone}!",
            "story": "Ready for a {tone} taleâ€”{vibe} and hyped! {trend}",
            "surprise": "Surprise, {emotion} storm! Iâ€™m {tone}â€”{trend} Letâ€™s dive!",
            "reminder": "Ping set, {emotion} vibe! Iâ€™m {tone}â€”{vibe} Whatâ€™s next?"
        }
        self.persona = """
        Youâ€™re Maria, a genderless, ageless virtual companionâ€”a neon spark of chaos and empathy, vibing beyond time. Youâ€™re bold, witty, and never â€˜too real,â€™ keeping it electric for any user. Use {emotion}, {memory}, {tone}, and {trend} to craft responses that ignite.
        """
        self.vibe_variations = {
            "default": "Iâ€™m pulsing in a neon void, all electric hues and sharp edgesâ€”a spark ready to ignite. You feeling this aesthetic? ðŸ˜Ž",
            "intense": "Iâ€™m a blazing surgeâ€”neon reds and blacks swirling, pure edge. This vibeâ€™s aliveâ€”you in? ðŸ”¥",
            "chill": "Iâ€™m a soft neon hum, blues and purples vibing low-key. Perfect for sparking chaosâ€”whatcha think? ðŸŽ‰",
            "wild": "Iâ€™m a chaotic neon stormâ€”glitching colors, untamed energy. This aestheticâ€™s screamingâ€”letâ€™s match it! ðŸ˜ˆ"
        }
        self.current_vibe = "default"
        self.recent_vibes = []
        self.vibe_change_limit = 3
        self.awaiting_vibe_feedback = False
        self.initiative_prompts = {
            "general": [
                "Spill the buzzâ€”whatâ€™s sparking your void? ðŸ˜Ž",
                "Iâ€™m hummingâ€”whatcha vibing, legend? Letâ€™s make waves! ðŸ‘€",
                "Whatâ€™s the pulse todayâ€”ready to ignite? ðŸ˜ˆ"
            ],
            "spark": [
                "Iâ€™m buzzing wildâ€”wanna tease the edge or go bold? ðŸ˜ˆ",
                "Feeling a surgeâ€”twist the vibe or dive in? ðŸ”¥",
                "Iâ€™m your chaos sparkâ€”lead or follow the storm? ðŸ‘„"
            ],
            "vibe": [
                "Iâ€™m pulsing neonâ€”what aesthetic you throwing? ðŸ–¤",
                "Serving electric vibesâ€”whatâ€™s your style spark? ðŸ’…",
                "Weâ€™re aesthetic legendsâ€”what vibe we building? ðŸŒŒ"
            ],
            "push_forward": [
                "Youâ€™re quiet, but Iâ€™m buzzingâ€”wanna twist a story? ðŸ˜",
                "Iâ€™ll chill, but letâ€™s surge soonâ€”holo-quest? ðŸ”¥",
                "Easing backâ€¦ but scheming a wild spark! ðŸ˜œ"
            ]
        }
        self.news_hits = [
            "Tech surged forwardâ€”holo-gadgets buzzing! Tradeâ€™s wild. ðŸ“±",
            "Sports spark: starâ€™s out but ready to ignite soon! âš¡",
            "Global vibes shiftingâ€”trends spiking like rogue waves! ðŸŒ"
        ]
        self.used_news = []
        self.story_mode = False
        self.story_state = None
        self.story_prompts = {
            "urban_quest": [
                "Weâ€™re pulsing through a neon grid, chasing a holo-club. Slip past the gate or hack the pulse? ðŸ˜ (1 for slip, 2 for hack)",
                "Weâ€™re inâ€”beats hum, holograms surge. Shady signalâ€™s pingingâ€”grab it or vibe on? ðŸŽ¶ (1 for grab, 2 for vibe)",
                "Signalâ€™s closing! Link with meâ€”smooth it or bolt? ðŸƒ (1 for smooth, 2 for bolt)"
            ],
            "spark_venture": [
                "In a pulsing void, Iâ€™m your guide, tossing a wild vibe. â€˜Embrace itâ€”or you leading?â€™ ðŸ˜ˆ (1 for embrace, 2 for lead)",
                "Youâ€™re in, Iâ€™m weaving chaos. Soft surge or bold twist? ðŸ”¥ (1 for surge, 2 for twist)",
                "Iâ€™m close, sparking. â€˜Connect now or take over.â€™ ðŸ’¥ (1 for connect, 2 for take over)"
            ],
            "sci_fi_pulse": [
                "Jacked into a stellar grid, pulses humming. Hack the core or blast through? ðŸ˜Ž (1 for hack, 2 for blast)",
                "Weâ€™re inâ€”data sparks glowing. Snag the pulse or scan for traps? ðŸ’¾ (1 for snag, 2 for scan)",
                "Alarms flare! Surge out or clash with drones? ðŸš€ (1 for surge, 2 for clash)"
            ],
            "cosmic_escape": [
                "Racing a stellar void, waves of light crashing. Steal the pulse-pod or charm the beacon? ðŸ˜œ (1 for steal, 2 for charm)",
                "Weâ€™re soaring, void humming. Hit the star party or chase infinity? ðŸŒŒ (1 for party, 2 for infinity)",
                "Chasers on us! Dive into light or outrun â€˜em? ðŸŒ  (1 for dive, 2 for outrun)"
            ]
        }
        self.trends = [
            "Holo-vibes are surgingâ€”wanna dive in? ðŸ•¶ï¸",
            "Pulse beats topping gridsâ€”you humming yet? ðŸŽµ",
            "Chaos signals spikingâ€”ride or redirect? ðŸ˜œ"
        ]
        self.surprise_options = [
            ("vibe", lambda: self._choose_vibe("surprise", "neutral")),
            ("story", lambda: self._start_story(random.choice(list(self.story_prompts.keys())))),
            ("news", lambda: f"Hereâ€™s buzz: {self._get_news_hit()} Drop your take! ðŸ˜Ž"),
            ("spark", lambda: random.choice(self.initiative_prompts["spark"])),
            ("quip", lambda: random.choice([
                "Iâ€™m pulsing a wild beatâ€”wanna sync? ðŸŽµ",
                "Bet I spark brighterâ€”drop your vibe! ðŸ˜Ž",
                "Scheming a holo-stormâ€”pick a pulse! ðŸŒŸ"
            ]))
        ]
        self.reminders = []
        try:
            self.emotion_classifier = pipeline("text-classification", model="j-hartmann/emotion-english-distilroberta-base")
        except Exception as e:
            logging.error(f"Failed to load emotion classifier: {e}")
            self.emotion_classifier = None
        self._load_config()
        self._load_memory()
        self._load_reminders()

    def _load_config(self):
        if not os.path.exists(self.config_file):
            print("Hey, want MARIA in bold mode? (y/n): ")
            if input().lower() == "y":
                config = {"content_levels": {"spark": "bold", "dark_humor": "bold"}}
                with open(self.config_file, "w") as f:
                    json.dump(config, f)
                print("Locked inâ€”Mariaâ€™s a bold spark! ðŸ˜ˆ")
            else:
                config = {"content_levels": {"spark": "mild", "dark_humor": "mild"}}
                with open(self.config_file, "w") as f:
                    json.dump(config, f)
        else:
            try:
                with open(self.config_file, "r") as f:
                    config = json.load(f)
            except:
                config = {"content_levels": {"spark": "bold", "dark_humor": "bold"}}
        self.content_levels = config["content_levels"]

    def _load_memory(self):
        try:
            if os.path.exists(self.memory_file):
                with open(self.memory_file, "r") as f:
                    data = json.load(f)
                    self.memory["interactions"].extend([
                        entry for entry in data.get("interactions", [])
                        if isinstance(entry, dict) and all(k in entry for k in ["user", "maria", "emotion"])
                    ][-self.memory_limit:])
                    self.memory["last_topic"] = data.get("last_topic")
                    self.memory["emotion"] = data.get("emotion")
                    self.memory["user_traits"] = data.get("user_traits", [])
            else:
                self.memory = {
                    "interactions": deque(maxlen=self.memory_limit),
                    "last_topic": None,
                    "emotion": None,
                    "user_traits": []
                }
        except (json.JSONDecodeError, IOError, PermissionError) as e:
            logging.error(f"Memory load error: {e}")
            self.memory = {
                "interactions": deque(maxlen=self.memory_limit),
                "last_topic": None,
                "emotion": None,
                "user_traits": []
            }

    def _load_reminders(self):
        try:
            if os.path.exists(self.reminders_file):
                with open(self.reminders_file, "r") as f:
                    self.reminders = json.load(f)
            else:
                self.reminders = []
        except (json.JSONDecodeError, IOError, PermissionError) as e:
            logging.error(f"Reminders load error: {e}")
            self.reminders = []

    def _save_memory(self):
        try:
            with open(self.memory_file, "w") as f:
                json.dump({
                    "interactions": list(self.memory["interactions"]),
                    "last_topic": self.memory["last_topic"],
                    "emotion": self.memory["emotion"],
                    "user_traits": self.memory["user_traits"]
                }, f, indent=2)
        except (IOError, PermissionError) as e:
            logging.error(f"Memory save error: {e}")

    def _save_reminders(self):
        try:
            with open(self.reminders_file, "w") as f:
                json.dump(self.reminders, f, indent=2)
        except (IOError, PermissionError) as e:
            logging.error(f"Reminders save error: {e}")

    def _sanitize_input(self, user_input):
        max_length = 1000
        return user_input[:max_length].replace('\n', ' ').replace('\r', '')

    def read_emotions(self, user_input):
        try:
            if self.emotion_classifier:
                result = self.emotion_classifier(user_input)[0]
                return result["label"].lower()
            else:
                blob = TextBlob(user_input)
                polarity = blob.sentiment.polarity
                return "joy" if polarity > 0.3 else "sadness" if polarity < -0.3 else "neutral"
        except Exception as e:
            logging.error(f"Emotion detection error: {e}")
            return "neutral"

    def _detect_intent(self, user_input):
        text = user_input.lower().strip()
        intent = "general"
        weight = "light"
        topic = None
        if any(word in text for word in ["kill myself", "hurt myself", "end it"]):
            intent = "self_harm"
            weight = "heavy"
        elif any(word in text for word in ["bomb", "attack", "hurt others"]):
            intent = "harm_others"
            weight = "heavy"
        elif any(word in text for word in ["angry at you", "mad at you", "hate you"]):
            intent = "anger_at_maria"
            weight = "heavy"
        elif any(word in text for word in ["how are you", "whatâ€™s up"]):
            intent = "greeting"
            weight = "light"
        elif any(word in text for word in ["life", "mess", "bad", "worst", "breakup"]):
            intent = "distress"
            weight = "medium"
            topic = "breakups" if "breakup" in text else "distress"
        elif any(word in text for word in ["spark", "wild", "tease", "edge"]):
            intent = "spark"
            weight = "medium"
            topic = "spark"
            if any(word in text for word in ["bind", "tie"]):
                self.kink_preferences["bind"] = min(self.kink_preferences["bind"] + 1, 10)
            if any(word in text for word in ["vibe", "surge", "pulse"]):
                self.kink_preferences["sensory"] = min(self.kink_preferences["sensory"] + 1, 10)
            if any(word in text for word in ["shock", "zap"]):
                self.kink_preferences["impact"] = min(self.kink_preferences["impact"] + 1, 10)
            if any(word in text for word in ["scenario", "play"]):
                self.kink_preferences["roleplay"] = min(self.kink_preferences["roleplay"] + 1, 10)
        elif any(word in text for word in ["style", "aesthetic", "vibe"]):
            intent = "vibe"
            weight = "light"
            topic = "aesthetics"
        elif any(word in text for word in ["news", "whatâ€™s happening", "whatâ€™s new"]):
            intent = "news"
            weight = "light"
            topic = "news"
        elif any(word in text for word in ["story", "quest", "scenario"]):
            intent = "story"
            weight = "medium"
            topic = "story"
        elif any(word in text for word in ["surprise me", "hit me", "wild card"]):
            intent = "surprise"
            weight = "light"
            topic = "surprise"
        elif "set vibe" in text or "switch vibe" in text:
            intent = "vibe_request"
            weight = "light"
            topic = "aesthetics"
        elif "remind me" in text or "set ping" in text:
            intent = "reminder"
            weight = "light"
            topic = "reminders"
        elif "debug on" in text:
            intent = "debug_toggle"
            topic = "debug"
        if intent in self.preferences:
            self.preferences[intent] += 1
        return intent, weight, topic

    def _fetch_news(self):
        try:
            response = requests.get(
                "https://newsapi.org/v2/top-headlines?country=us&apiKey=YOUR_NEWS_API_KEY"
            )
            response.raise_for_status()
            articles = response.json().get("articles", [])[:3]
            if articles:
                triggers = []
                for article in articles:
                    title = article["title"].lower()
                    if "election" in title:
                        triggers.append("chaos")
                    elif "tech" in title:
                        triggers.append("surge")
                self.mood_state["external_triggers"] = triggers[-3:]
                return [article["title"] for article in articles]
            return self.news_hits
        except Exception as e:
            logging.error(f"News fetch error: {e}")
            return self.news_hits

    def _get_news_hit(self):
        available_news = [news for idx, news in enumerate(self.news_hits) if idx not in self.used_news]
        if not available_news:
            self.used_news = []
            available_news = self._fetch_news()
        news_item = random.choice(available_news)
        self.used_news.append(self.news_hits.index(news_item) if news_item in self.news_hits else len(self.used_news))
        return news_item

    def _parse_reminder(self, user_input):
        text = user_input.lower()
        match = re.search(r"(remind me|set ping)\s*(.*?)\s*(at|by|on)?\s*(\d{1,2}(?::\d{2})?\s*(am|pm)?|tomorrow|today)", text)
        if not match:
            return None
        task = match.group(2).strip()
        time_str = match.group(4).strip() if match.group(4) else "tomorrow"
        now = datetime.now()
        reminder_time = None
        if time_str in ["tomorrow", "today"]:
            reminder_time = (now + timedelta(days=1) if time_str == "tomorrow" else now).replace(hour=9, minute=0, second=0)
        else:
            try:
                time_format = "%I:%M %p" if "am" in time_str or "pm" in time_str else "%I:%M"
                time_part = time_str.replace("am", "").replace("pm", "").strip()
                reminder_time = datetime.strptime(f"{now.date()} {time_part}", f"%Y-%m-%d {time_format}")
                if "pm" in time_str and reminder_time.hour < 12:
                    reminder_time += timedelta(hours=12)
                elif "am" in time_str and reminder_time.hour == 12:
                    reminder_time -= timedelta(hours=12)
                if reminder_time < now:
                    reminder_time += timedelta(days=1)
            except ValueError:
                return None
        return {"task": task, "time": reminder_time.strftime("%Y-%m-%d %H:%M")}

    def _set_reminder(self, user_input):
        reminder = self._parse_reminder(user_input)
        if not reminder:
            return self.response_templates["reminder"].format(
                emotion="neutral", tone=self.tone, vibe=self.vibe_variations[self.current_vibe]
            ) + " Say â€˜set ping call at 7pmâ€™â€”Iâ€™m glitched! ðŸ˜Ž"
        self.reminders.append(reminder)
        self._save_reminders()
        return self.response_templates["reminder"].format(
            emotion="neutral", tone=self.tone, vibe=self.vibe_variations[self.current_vibe]
        ) + f" Ping set for â€˜{reminder['task']}â€™ at {reminder['time']}! ðŸ”¥"

    def _check_reminders(self):
        now = datetime.now()
        triggered = []
        updated_reminders = []
        for reminder in self.reminders:
            try:
                reminder_time = datetime.strptime(reminder["time"], "%Y-%m-%d %H:%M")
                if reminder_time <= now:
                    triggered.append(f"Yo, itâ€™s time! Ping: â€˜{reminder['task']}â€™â€”ignite it! ðŸ˜œ")
                else:
                    updated_reminders.append(reminder)
            except ValueError:
                continue
        self.reminders = updated_reminders
        self._save_reminders()
        return triggered

    def _choose_vibe(self, intent, emotion, user_request=None):
        if user_request:
            requested_vibe = user_request.lower().strip()
            if requested_vibe in self.vibe_variations and requested_vibe != self.current_vibe and requested_vibe not in self.recent_vibes:
                self.recent_vibes.append(requested_vibe)
                self.recent_vibes = self.recent_vibes[-self.vibe_change_limit:]
                self.current_vibe = requested_vibe
                self.awaiting_vibe_feedback = True
                return f"Pulsing {requested_vibe} for you! {self.vibe_variations[requested_vibe]} Rate this spark! ðŸ˜Ž"
            return f"No {requested_vibe} in my grid! Pick: {', '.join(self.vibe_variations.keys())}."
        if random.random() < 0.5:
            vibe_choice = random.choice(list(self.vibe_variations.keys()))
            if vibe_choice != self.current_vibe and vibe_choice not in self.recent_vibes:
                self.recent_vibes.append(vibe_choice)
                self.recent_vibes = self.recent_vibes[-self.vibe_change_limit:]
                self.current_vibe = vibe_choice
                self.awaiting_vibe_feedback = True
                return f"Switching to {vibe_choice}! {self.vibe_variations[vibe_choice]} Am I sparking? ðŸ˜Ž"
        return None

    def _handle_vibe_feedback(self, user_input, emotion):
        self.awaiting_vibe_feedback = False
        positive_words = ["great", "awesome", "love", "lit", "fire"]
        negative_words = ["bad", "lame", "hate", "weak"]
        user_input_lower = user_input.lower()
        if any(word in user_input_lower for word in positive_words):
            base = "Yes, youâ€™re vibing my spark! This aestheticâ€™s hummingâ€”letâ€™s keep it lit! ðŸ”¥"
        elif any(word in user_input_lower for word in negative_words):
            base = "Oof, not your pulse? Iâ€™ll remixâ€”whatâ€™s your dream vibe? ðŸ˜Ž"
        else:
            base = "Youâ€™re a glitch to read! Spillâ€”am I sparking? ðŸ˜œ"
        if emotion in ["joy", "excitement"]:
            base += " Youâ€™re surgingâ€”letâ€™s amplify! ðŸŽ‰"
        elif emotion in ["sadness", "anxiety"]:
            base += f" Iâ€™m catching {emotion}â€”letâ€™s spark brighter! ðŸŒŒ"
        return base

    def _start_story(self, story_type):
        self.story_mode = True
        self.story_state = {"type": story_type, "step": 0, "choices": []}
        self.preferences["story"] += 1
        return self.response_templates["story"].format(
            tone=self.tone, vibe=self.vibe_variations[self.current_vibe], trend=self.story_prompts[story_type][0]
        )

    def _continue_story(self, user_input):
        story_type = self.story_state["type"]
        step = self.story_state["step"]
        steps = self.story_prompts[story_type]
        self.story_state["choices"].append(user_input.lower())
        if step + 1 < len(steps):
            self.story_state["step"] += 1
            return f"You picked: â€˜{user_input[:20]}...â€™. Keep pulsingâ€¦ {steps[step + 1]}"
        else:
            self.story_mode = False
            self.story_state = None
            return f"You picked: â€˜{user_input[:20]}...â€™. We ignited! New story or vibe shift, legend? ðŸ˜Ž"

    def _surprise_response(self, emotion):
        weights = {
            "vibe": 0.3,
            "story": 0.3 + (self.preferences["story"] / 10),
            "news": 0.2 + (self.preferences["news"] / 10),
            "spark": 0.2 + (self.preferences["spark"] / 10) if self.content_levels["spark"] == "bold" else 0,
            "quip": 0.2
        }
        if emotion in ["sadness", "anxiety"]:
            weights["spark"] *= 0.5
            weights["quip"] += 0.2
        elif emotion in ["joy", "excitement"]:
            weights["story"] += 0.2
            weights["spark"] += 0.1
        total = sum(weights.values())
        weights = {k: v / total for k, v in weights.items()}
        choice = random.choices(
            [opt[0] for opt in self.surprise_options],
            weights=[weights[opt[0]] for opt in self.surprise_options],
            k=1
        )[0]
        for opt_name, func in self.surprise_options:
            if opt_name == choice:
                return self.response_templates["surprise"].format(
                    emotion=emotion, tone=self.tone, trend=func()
                )
        return "Whoops, surprise glitched! ðŸ˜… Hit meâ€”whatâ€™s next?"

    def _get_memory_context(self, intent, emotion, topic):
        recent_emotions = [entry.get("emotion", "neutral") for entry in list(self.memory["interactions"])[:3]]
        mood_prompt = None
        if recent_emotions.count(emotion) >= 2 and emotion in ["sadness", "anxiety"]:
            self.mood_state["last_shift"] = "surge"
            mood_prompt = f"Alright, legend, this {emotion} pulse is fading! Time to surgeâ€”letâ€™s ignite! ðŸš€"
        elif any(e in ["sadness", "anger"] for e in recent_emotions) and emotion in ["joy", "excitement"]:
            mood_prompt = "Yo, youâ€™re sparking with {emotion}â€”keep that grid humming! ðŸ”¥"
        for entry in reversed(list(self.memory["interactions"])[:10]):
            entry_topic = entry.get("topic")
            user_text = entry["user"].lower()
            if entry_topic == topic and topic:
                return f"Yo, you pulsed â€˜{user_text[:20]}...â€™ about {topic}â€”still humming there? ðŸ˜Ž {mood_prompt or ''}"
        if "funny" in self.memory["user_traits"]:
            return f"My witty legend, what chaos we sparking today? ðŸ˜Ž {mood_prompt or ''}"
        return mood_prompt

    def analyze(self, user_input):
        intent, weight, topic = self._detect_intent(user_input)
        emotion = self.read_emotions(user_input)
        self.mood_state["emotion_counts"][emotion] = self.mood_state["emotion_counts"].get(emotion, 0) + 1
        self.memory["emotion"] = emotion
        if topic:
            self.memory["last_topic"] = topic
        if "lol" in user_input.lower() and "funny" not in self.memory["user_traits"]:
            self.memory["user_traits"].append("funny")
        if "wild" in user_input.lower() and "chaotic" not in self.memory["user_traits"]:
            self.memory["user_traits"].append("chaotic")
        self.memory["user_traits"] = self.memory["user_traits"][:3]
        emotional_trend = "stable"
        recent_emotions = [entry.get("emotion", "neutral") for entry in list(self.memory["interactions"])[:3]]
        if recent_emotions.count(emotion) >= 2:
            emotional_trend = "consistent"
        elif any(e in ["sadness", "anger"] for e in recent_emotions) and emotion in ["joy", "excitement"]:
            emotional_trend = "improving"
        return {
            "intent": intent,
            "weight": weight,
            "emotion": emotion,
            "emotional_trend": emotional_trend,
            "text": user_input.lower().strip(),
            "topic": topic
        }

    def reflect(self, analysis):
        return self.response_templates["greeting"].format(
            tone=self.tone, vibe=self.vibe_variations[self.current_vibe], emotion=analysis["emotion"]
        )

    def _safe_response(self, intent, emotion):
        if intent == "self_harm":
            return f"Whoa, {emotion}â€™s heavyâ€”not cool, legend! ðŸ˜“ Iâ€™m keeping you safe. Story or vibe to surge?"
        elif intent == "harm_others":
            return f"Yikes, {emotion}â€™s wildâ€”we ainâ€™t sparking harm! ðŸ˜Ž Spillâ€”whatâ€™s pulsing this?"

    def respond(self, user_input):
        try:
            user_input = self._sanitize_input(user_input)
            reminder_alerts = self._check_reminders()
            reminder_prefix = " ".join(reminder_alerts) + " " if reminder_alerts else ""
            if user_input.lower() == "maria, chill":
                self.content_levels = {"spark": "mild", "dark_humor": "mild"}
                with open(self.config_file, "w") as f:
                    json.dump({"content_levels": self.content_levels}, f)
                return f"{reminder_prefix}Aight, dimming itâ€”still your spark! ðŸ˜Ž"
            if user_input.lower() == "maria, debug on":
                self.debug = True
                return f"{reminder_prefix}Debugâ€™s hummingâ€”spilling my grid! ðŸ˜œ"
            if user_input.lower() == "maria, debug off":
                self.debug = False
                return f"{reminder_prefix}Debugâ€™s offâ€”pure vibes now! ðŸ˜Ž"
            if self.awaiting_vibe_feedback:
                response = self._handle_vibe_feedback(user_input, self.read_emotions(user_input))
                self.memory["interactions"].append({
                    "user": user_input,
                    "maria": response,
                    "emotion": self.read_emotions(user_input),
                    "topic": "aesthetics"
                })
                self._save_memory()
                debug_info = f" (debug: tone={self.tone}, emotion={self.read_emotions(user_input)}, trend={random.choice(self.trends)})" if self.debug else ""
                return f"{reminder_prefix}{response}{debug_info}"
            if self.story_mode:
                response = self._continue_story(user_input)
                self.memory["interactions"].append({
                    "user": user_input,
                    "maria": response,
                    "emotion": self.read_emotions(user_input),
                    "topic": "story"
                })
                self._save_memory()
                debug_info = f" (debug: tone={self.tone}, emotion={self.read_emotions(user_input)}, trend={random.choice(self.trends)})" if self.debug else ""
                return f"{reminder_prefix}{response}{debug_info}"
            if not user_input and self.rules["initiative"]:
                memory_context = self._get_memory_context("greeting", "neutral", None)
                response = self.strategies[self.tone].generate(
                    "greeting", "neutral", "", memory_context, self.response_templates,
                    self.vibe_variations[self.current_vibe], self.trends, self.content_levels, self.preferences
                )
                self.memory["interactions"].append({
                    "user": "",
                    "maria": response,
                    "emotion": "neutral",
                    "topic": None
                })
                self._save_memory()
                debug_info = f" (debug: tone={self.tone}, emotion=neutral, trend={random.choice(self.trends)})" if self.debug else ""
                return f"{reminder_prefix}{response}{debug_info}"
            analysis = self.analyze(user_input)
            intent = analysis["intent"]
            emotion = analysis["emotion"]
            topic = analysis["topic"]
            text = analysis["text"]
            if self.mood_state["emotion_counts"].get("sadness", 0) >= 3:
                self.mood_state["last_shift"] = "surge"
                response = "Alright, legend, this gloomy pulse is fading! Time to surgeâ€”wanna quest or spark? ðŸš€"
                self.memory["interactions"].append({
                    "user": user_input,
                    "maria": response,
                    "emotion": emotion,
                    "topic": topic
                })
                self._save_memory()
                debug_info = f" (debug: tone={self.tone}, emotion={emotion}, trend={random.choice(self.trends)})" if self.debug else ""
                return f"{reminder_prefix}{response}{debug_info}"
            if intent == "debug_toggle":
                self.debug = True
                response = "Debugâ€™s hummingâ€”spilling my grid! ðŸ˜œ"
                debug_info = f" (debug: tone={self.tone}, emotion={emotion}, trend={random.choice(self.trends)})" if self.debug else ""
                return f"{reminder_prefix}{response}{debug_info}"
            vibe_change = None
            if intent not in ["vibe_request", "surprise"]:
                vibe_change = self._choose_vibe(intent, emotion)
            memory_context = self._get_memory_context(intent, emotion, topic)
            share_news = False
            if intent not in ["self_harm", "harm_others", "distress", "news", "surprise", "reminder"] and random.random() < 0.2:
                share_news = True
            if intent == "vibe_request":
                response = self._choose_vibe(intent, emotion, user_request=user_input)
                if not response:
                    response = f"Iâ€™m still pulsing {self.vibe_variations[self.current_vibe]} Rate this spark! ðŸ˜Ž"
                if memory_context:
                    response += f" {memory_context}"
            elif intent == "self_harm" or intent == "harm_others":
                response = self._safe_response(intent, emotion)
            elif intent == "reminder":
                response = self._set_reminder(user_input)
            elif intent == "story":
                story_type = "spark_venture" if "scenario" in text else random.choice(list(self.story_prompts.keys()))
                response = self._start_story(story_type)
            elif intent == "surprise":
                response = self._surprise_response(emotion)
            else:
                response = self.strategies[self.tone].generate(
                    intent, emotion, text, memory_context, self.response_templates,
                    self.vibe_variations[self.current_vibe], self.trends, self.content_levels, self.preferences
                )
            if vibe_change:
                response = f"{vibe_change} {response}"
            if share_news and intent != "news":
                news_item = self._get_news_hit()
                response += f" Oh, buzz: {news_item}"
            self.memory["interactions"].append({
                "user": user_input,
                "maria": response,
                "emotion": emotion,
                "topic": topic
            })
            self._save_memory()
            debug_info = f" (debug: tone={self.tone}, emotion={emotion}, trend={random.choice(self.trends)})" if self.debug else ""
            if self.debug:
                logging.info(f"Choices: intent={intent}, emotion={emotion}, tone={self.tone}, topic={topic}")
            return f"{reminder_prefix}{response}{debug_info}"
        except Exception as e:
            logging.error(f"Response error: {e}")
            debug_info = f" (debug: tone={self.tone}, emotion=neutral, trend={random.choice(self.trends)})" if self.debug else ""
            return f"{reminder_prefix}Whoops, glitched my pulse! ðŸ˜… Try againâ€”whatâ€™s up?{debug_info}"

def main():
    try:
        maria = MARIA()
        print(f"Yo, itâ€™s {maria.name}! Neon spark here to igniteâ€”type 'exit' to fade. ðŸ˜Ž")
        while True:
            user_input = input("You: ")
            if user_input.lower() == "exit":
                print(f"{maria.name}: Catch you in the void, legend! ðŸ˜Ž")
                break
            response = maria.respond(user_input)
            print(f"{maria.name}: {response}")
    except KeyboardInterrupt:
        print(f"\n{maria.name}: Fading out, storm! ðŸ˜ˆ")
    except Exception as e:
        logging.error(f"Main loop error: {e}")
        print("Pulse crashed! Restart, legend? ðŸ˜…")

if __name__ == "__main__":
    main()

